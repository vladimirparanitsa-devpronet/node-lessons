/*
  Вот делаете Вы игру на канвас-движке, и хотите следить за движущимися объектами.
  Можно просто добавить свойство.
*/

if (element.isMoving) {
  smoothAnimations(element);
}
element.isMoving = true;

/*
  При таком подходе существует несколько потенциальных проблем.
  Все они связаны с тем, что c обьектами может работать не только ваш текущий код.
  Конечно, можно сделать название свойства таким длинным и дурацким,
  что никто в жизни его не станет к ним лезть:
*/
element.__$animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;

/*
  Но не стоит на этом останавливаться. Можно генерировать практически уникальное
  имя свойства, используя криптографию:
*/

let isMoving = SecureRandom.generateName();

if (element[isMoving]) {
  smoothAnimations(element);
}
element[isMoving] = true;

/*
  Но такой синтаксис приводит к проблемам при отладке кода.
  Каждый раз, когда вы делаете console.log() для элемента с таким свойством,
  вы будете получать длинную бессмысленную строку.
  А если таких свойств должно быть много?

  Разве это так сложно? Нам нужен просто один маленький boolean!
*/

/*
  РЕШЕНИЕ:
  Символы — это значения, которые используются в качестве названия свойств
  без риска пересечения пространств имен.
  Важно отметить - символы не приватные ключи, а уникальные,
  хотя появилась тенденция использовать их для создания приватных ключей.
*/

let isMoving = Symbol("object is moving");

if (element[isMoving]) {
  smoothAnimations(element);
}
element[isMoving] = true;

/*
  ЧУДЕСНО!
  Теперь не возможно обратиться к свойству, не имея ссылку на символ.
  И наиболее распространённые способы просмотра свойств объектов
  просто игнорирут ключи-символы - например,
  в цикле for…in или Object.keys(obj) и Object.getOwnPropertyNames(obj).

  К символам объекта можно обращаться только через [ ] скобки.
  При создании можно указать optional параметр, который служит только для
  помощи при отладке и не изменяет поведение символа.
  Обратиться к символу через него нельзя.

  После создания символы невозможно изменить, а только пересоздать.
  Сами свойства, конечно же можно.
*/

typeof Symbol() === "symbol"

// Символы не могут быть автоматически конвертированны в строку.

let sym = Symbol("<3");
"your symbol is " + sym // TypeError

//Избежать ошибки поможет явная конвертация символа в строку

String(sym) === "Symbol(<3)"

//Все символы уникальны:

let firstScore = Symbol('score');
let secondScore = Symbol('score');

firstScore === secondScore; // false

/*
  С появлением символов объект Object был расширен методом, который позволяет
  получить все символы объекта. Наличие этого метода лишает нас возможности
  создавать по-настоящему приватные свойства:
*/

let userSymbols = Object.getOwnPropertySymbols(user);
let roleSymbol = userSymbols[0];
user[ roleSymbol ]; // 'admin'

/*
  Три способа получения символов:
*/

let sym1 = Symbol('qwe'); // каждый раз будет возвращаться новый уникальный символ;
let sym2 = Symbol.for("www"); // который позволяет хранить символы глобально для среды текущего выполнения
let key = Symbol.keyFor(sym2); // www, позволяет получить ключ, по которому символ добавлен в реестр.
let iterator = Symbol.iterator; //использование описанных в стандарте символов вроде Symbol.iterator.
