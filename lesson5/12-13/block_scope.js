
/*
ПРОФИТЫ блочной видимости:
1. Делает использование функций в циклах тривиальным.
2. Предотвращает подъем переменных за пределы области видимости.
3. Предотвращает двойное объявление переменной в той же зоне видимости.
4. Устраняет необходимость IIFE.
*/


/*
  До введения стандарта ES6 основой всех областей видимости являлись функции.
  У любой функции существует своя область видимости
*/

var num = 10;
var func = function() {
  var num = 20;
  console.log(num); // 20
};
console.log(num); // 10

/*
  До ЕS6 если нужно было реализовать блок со своей областью видимости,
  то использовали IIFE (иффи - выражение немедленно вызывающейся функции)
*/

(function() {
  // Переменные a и b находятся в области видимости
  // самовызывающейся анонимной функции и не доступны
  // на более высоких уровнях
  var a = 10;
  var b = 20;
  // Для вывода переменной в глобальную область видимости
  // используется подобная конструкция
  window.b = b;
})();
console.log(a); // undefined
console.log(b); // 20

/*
  Иффи работали исключительно с функциями, а на другие блочные конструкции
  не действовали.
  Теперь появилась блочная область видимости (block scoping).
  Все, что нам необходимо для создания новой области видимости - фигурные скобки { }.
  Вместо использования оператора var, который мы использовали
  для объявления переменных внутренней (или глобальной) области видимости,
  мы можем использовать let и const для объявления блочной:
*/

var a = 2;
{
  let a = 3;
  console.log( a ); // 3
}
console.log( a ); // 2

/*
  Эти операторы тоже hoist`ятся, но не инициализируют переменные при входе
  в функцию, поэтому можно столкнуться с Temporary Dead Zone.
  Мы получим ReferenceError, который будет вызван ранним обращением к переменной,
  до того как она была объявлена или инициализирована.

  Поэтому лучше все переменные объявлять в начале блока.
*/

{
  console.log( a ); // undefined
  console.log( b ); // ReferenceError!

  var a; // резервируется имя, инициализируется как undefined;
  let b; // только резервируется имя.
}

/*
  Подробней о хоистинге - при использовании ключевого слова let происходит
  поднятие переменных (hoisting), хотя на первый взгляд может показаться
  что это не так. Но сам процесс поднятия реализуется совершенно другим образом:
*/

let b = 20;
if (true) {
  console.log(b); // ReferenceError: b is not defined
  let b = 10;
}

/*
  Несмотря на то, что переменная b была объявлена вне блока и поэтому
  должна быть доступна, мы все равно получим ReferenceError.
  Здесь столкнулись с “временной мёртвой зоной”: в этом блоке
  переменная b своя, и она ещё не инициализированна, но имя переменной уже
  зарезервированно. Поэтому лучше объявлять все переменные в начале блока.
*/
/*
  Весь смысл ВМЗ — легче вылавливать ошибки там,
  где обращение к переменной до её объявления приводит к неожиданностям.
  Это зачастую происходило в ES5 из-за поднятия и непродуманных соглашений
  о стиле кода. Теперь переменные работают так, как в многих других языках.
*/

if (false) {
  var a = 10;
}
console.log(a); // Reference Error? WRONG! Undefined!

/*
  Код внутри конструкции if не запускался,
  а значит и перменная a не была инициализирована. Логично предположить,
  что единственным возможным результатом является ошибка
  (попытка обратиться к несуществующей переменной обычно выдает ReferenceError).
  На самом деле результат будет undefined изза hoisting`a переменных.
*/

/*
  Теперь всё гораздо проще!
  Рассмотрим решение частой проблемы при использовании var в цикле for:
  для каждой итерации создаётся новая i, которая не hoist`ится за пределы цикла.
*/

var funcs = [];
for (let i = 0; i < 5; i++) {
  funcs.push(function(){
    console.log( i );
  });
}
funcs[3](); // 3
console.log(i); // ReferenceError!

/*
  Временная мёртвая зона не распространяется на функции до первого их вызова:
*/

var f = function() {
  return num;
};
let num = 10;
console.log(f()); // 10

/*
  Но если вы попытаетесь вызвать функцию f до того,
  как будет объявлена переменная num, то всё равно получите ошибку:
*/

var f = function() {
  return num;
};
console.log(f()); // ReferenceError: num is not defined
let num = 10;

/*
  Так как переменная а не была объявлена, то единственный безопасным способом
  проверить ее на существование будет использование оператора typeof.
  Но даже typeof бросает ошибку если переманная была объявлена позже!
*/

{
  if (typeof b === "undefined") { // ReferenceError!
    console.log('b is undefined');
  }
  let b;
}


/*
  const
  Надо обязательно присваивать значение при объявлении.
  По-умолчанию константа не получает значение undefined, поэтому
  если нужен undefined, надо явно это указать.
*/

const a; // SyntaxError: Missing initializer in const declaration
const a = undefined; //undefined

/*
  После объявления const нельзя менять только примитивные типы данных
  или ссылку на составные. То-есть это не неизменное значение,
  а неизменная ссылка на значение.
*/

const lit = 4;
lit = 5; // TypeError: Литерал изменить нельзя

const obj = { a: 1 };
obj.a = 2; // Значения внутри объекта изменить можно
obj = { a: 3 }; // TypeError: Ссылку менять нельзя

const arr = [1, 2, 3];
arr.push(4); // Значения внутри массива изменить можно
arr = [4, 3, 2, 1]; // TypeError: Ссылку менять нельзя


/*
  Блочная область видимости функций
  Начиная с ES6, подразумевается, что функции которые были объявлены в блоке,
  буду иметь его область видимости (блочную). До ES6, спецификация умалчивала
  по этому поводу, в отличии от различных конкретных реализации.
  Тем не менее, сейчас спецификация соответствует реальности.
*/

{
  foo(); // работает!

  function foo() {
    console.log('it works!');
  }
}

foo(); // ReferenceError

/*
  Тут функция объявлена в блочной области видимости и не доступна из вне.
  Но в отличии от объявления let, с которым мы не можем работать до того,
  как такая переменная будет проиницилизированна,
  в данном случае ошибки TDZ не возникает.
*/
